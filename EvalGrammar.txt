eval(env, expr)
:: ([string, x..], _)       --> apply(lookup(string, env), eval(env, [x..]), env)
:: ([number, x..], _)       --> apply(lookup(number, env), eval(env, [x..]), env)
:: ([other      ], _)       --> other
:: ([other , x..], _)       --> eval(env, [x..])
:: (_            , _)       --> expr

lookup(env, key)
:: ("x", {x     })          --> x
:: ("x", {parent})          --> lookup(parent, "x")
:: (_  , _       )          --> null

apply(func, params, env)
## NOTE: params always gets advanced with each eval (i.e. processing skips past elements "consumed" as arguments)
:: (native                   , _, _)    --> native(params)
:: ({body:native, args:[x..]}, _, _)    --> native(newEnv(func, [eval(env, params)..], env, <caller_of_apply>), body)
:: ({body       , args:[x..]}, _, _)    --> eval  (newEnv(func, [eval(env, params)..], env, <caller_of_apply>), body)
:: (_                        , _, _)    --> null

newEnv(func, args, env, cc) --> setArgs(func, args, {
                                  thisFunc: func,
                                  parent  : func.parent,
                                  caller  : env,
                                  return  : (function that re-routes execution into cc),
                                  scope   : (this entire outer object),
                                  args    : args
                                })

setArgs(func, params, obj)
:: ({args:["a"..]}, [x..], {p..}) --> {a:x.., p..}
:: (_             , _    , _    ) --> obj