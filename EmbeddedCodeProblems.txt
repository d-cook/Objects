PROBLEM:

    How to evaluate cond, but not true/false code (without a "syntax" or "macro" rule) in:
    ['if', ['cond'..], [true-code], [false-code]]

OPTIONS:

    ['if', ['cond'..], ['returns-a-func'], ['returns-a-func']]       ex: ['lambda', ['returns-args'], ['returns-a-block']]
    ['if', ['cond'..], ['returns-a-block'], ['returns-a-block']]     ex: ['list', 'a', 'b', ['list', 'c', 'd'], 'e']

    ['if', ['cond'..], {true:['true-code'],false:['false-code']}]    ex: ['a', 'b', ['c', 'd'], 'e']

    ['if', 'cond'.., ['true-code'], ['false-code']]      (REBOL syntax and semantics: all code to be evaluated in same
                                                          context as op ('if') resides within the same block. Nested
                                                          blocks are data or code, and is NOT automatically evaluated).

    ['if', ['cond'..], {block:['true-code']}, {block:['false-code']}]  (Compromise between REBOL syntax & objects)

    ['if', [['cond'..]], ['true-code'], ['false-code']]  (all args wrapped in a SINGLE block. Any following are not evaled)
    ['if', ['cond'..], [['true-code'], ['false-code']]]  (Variant of above: the unevaled code-blocks are wrapped instead)
    {'op':'if', args:[{op:'cond'..}], code:[..]}         (Variant of above: use objects instead of arrays for code)

QUESTIONS:

    If a block, then how is scope preserved?
        (By manually evaling it within the env of the caller)

    If embedded in an object, how can it refer to external code?
        (By manually evaling it within the env of the caller)

    Interop between code-blocks, lambdas, and native CPS-functions (e.g. before/after compile)?
        (Handle different types differently, or pass a block embeds & invokes the function directly)
        (Compiler recognizes ops and where to look for each)
        (Special pattern for code-blocks that compiler can identify (danger of false-positives))
        (Compiler specifically recognizes & optimizes for lambdas)

    How can compiler differentiate between operations in the REBOL syntax?
        (Compiler must look-up each as it goes)
        (Some other indicator must be added to make them distinguishable without looking-up ops)

    If separating args and code-blocks explicitly, then how are code-blocks accessed and scoped?
        (Some special env property. There's already "args[n]", how about "code[n]"?)
        (Scoping must happen manually (eval within env of caller) to allow for DSLs ("dialects"))

-----------------------------------------------------

REBOL-style:
-----------
+ block literals (and thus, code literals)
+ symbols auto-eval
+ distinction between evaled and non-evaled code

Scheme-style:
------------
+ simple strings
+ distinction between operations
+ compiler does not have to lookup specific functions

OVERALL "BEST":
* Compiler does not need to lookup funcs to be able to call them (bc they can change at runtime).
* Ergo, need to be able to statically distinguish between args of one call and another.
* Ergo, non-eval items (e.g. nested code-blocks) must be identifiable in a static/syntactic way.
* Need to allow non-eval items to be passed amid normal arguments, so indication must be on items themsevles, not on overall command
* Prefer indication that does not require special handling by interpreter (e.g. so any "thing" can be passed as what it is)
* Possible solution: ['if', condition, {code:[..true..]}, {code:[..false..]}]
* Possible solution 2: Just use normal wrapped-functions, but change semantics so that "scopeless" (parentless) funcs evaluate within
  the context of their caller (or within the context of the code within which they are embedded), essentially as lambdas/closures.
  - Arrived at this because the other "potential solution" would require wrapped-native funcs (e.g. in the case of compiled code) to
    be passed like this: ['if', condition, {code:[{code:func}, ...]}, ...]. Why not just: ['if', condition, {code:func}, ...]
  - Also, things like "if" or "loop" could rely on the arg-names of the func rather than by messing directly with the caller's scope.
    So instead of: ['each', aContainer, 'key', 'val', {code:[...]}], do this: ['each', aContainer, {args:['key', 'val'], code:[...]}]